#! /bin/bash

HERE=$( dirname "$0" )
PGM_BASENAME=$( basename "$0" )

: ${STAT_DATA_DIR:="/var/pc_stats"}

: ${RUN_STATES_DIR:="/var/run_states"}

: ${GELF_UDP_HOST=''}
: ${GELF_UDP_PORT=''}
: ${SERVICE_NAME='_dev_'}

#
# check arg = week number
#

Usage ()
{
    msg="$@"
    (
	echo "ERROR:  ${msg}"
	echo "Usage ${PGM_BASENAME} --env.GELF_UDP_HOST <hostname of GELF udp server> --env.GELF_UDP_PORT <UDP port number of GELF server>" 
    ) 1>&2
    exit 1
}

#
# args
#

while [[ -n "$1" ]]
do
     case "$1" in
	--env.GELF_UDP_HOST )
	    shift
	    GELF_UDP_HOST="$1"
	    ;;
	--env.GELF_UDP_PORT )
	    shift
	    GELF_UDP_PORT="$1"
	    ;;
	--env.SERVICE_NAME )
	    shift
	    SERVICE_NAME="$1"
	    ;;
	* )
	    Usage "bad arg: $1"
	    exit 1
	    ;;
     esac
     shift
done

#
# check if any mandatory arg has been provided
#
if [[ -z "${GELF_UDP_HOST}" ]]
then
    Usage "GELF_UDP_HOST not specified"
    exit 1
fi

if [[ -z "${GELF_UDP_PORT}" ]]
then
    Usage "GELF_UDP_PORT not specified"
    exit 1
fi



#
# Check the folder containing the stats
# =====================================

if [[ -d "${STAT_DATA_DIR}" ]] # && [[ -r "${STAT_DATA_DIR}" ]]
then
    :
else
    Usage "could not acces stat folder \"${STAT_DATA_DIR}\""
    exit 1
    #NOT REACHED
fi

#
# Get all files not teated since last call
#

if [[ -r "${RUN_STATES_DIR}/last_call.status" ]]
then
    all_stat_files=$(
	find "${STAT_DATA_DIR}" -newer "${RUN_STATES_DIR}/last_call.status" -type f -print
		  )
else
    all_stat_files=''
fi    

if [[ -z $( echo "${all_stat_files}" | tr -d '[:blank:]' ) ]]
then
    # We got a empty string => no file matched
    # generate a simple empty file
    touch /tmp/no_rproxy_stats.txt
    all_stat_files=/tmp/no_rproxy_stats.txt
fi
    

remember_to_cache_attribute_for_ip ()
{
    real_ip="$1"
    attribute_name_to_cache="$2"
    attribute_value_to_cache="$3"

    echo "${attribute_value_to_cache}" > "${RUN_STATES_DIR}/cache_data_${real_ip}_last_value_for_${attribute_name_to_cache}"
}

guess_from_cache_attribute_for_ip ()
{
    real_ip="$1"
    attribute_name_to_cache="$2"

    if [[ -r "${RUN_STATES_DIR}/cache_data_${real_ip}_last_value_for_${attribute_name_to_cache}" ]]
    then
	attribute_value_from_cache=$( cat "${RUN_STATES_DIR}/cache_data_${real_ip}_last_value_for_${attribute_name_to_cache}" )
    else
	attribute_name_to_cache=''
    fi

    echo "${attribute_value_from_cache}"
}


generateAndSendGELFLog ()
{
    # "1616779865" "bernhara" "login" "success" "90.8.128.173" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36"
    
    line="$@"
    # echo ">>>>>>>>>>>>>>>>>>>>>${line}<<<<<<<<<<<<<<<<<<<<<"

    protected_line=$(
	echo "${line}" | \
	    sed \
		-e "s/^\"/'/" \
		-e "s/\" \"/' '/g" \
		-e "s/\"$/'/"
   )
    
    # echo ">>>>>>>>>>>>>>>>>>>>>${protected_line}<<<<<<<<<<<<<<<<<<<<<"

    # FIXME: eval should ne be required
    eval declare -a tab=( "${protected_line}" )

    epoch_time=${tab[0]}
    action=${tab[1]}
    param=${tab[2]}
    status=${tab[3]}
    real_ip=${tab[4]}
    user_agent=${tab[5]}

    pc_login=''
    doc_ref=''
    vin=''

    case "${action}" in

	"login" )
	    pc_login="${param}"
	    remember_to_cache_attribute_for_ip ${real_ip} "pc_login" "${pc_login}" 
	    ;;

	"documentation" )
	    doc_ref="${param}"
	    pc_login=$( guess_from_cache_attribute_for_ip ${real_ip} "pc_login" )
	    ;;

	"vin" )
	    vin="${param}"
	    pc_login=$( guess_from_cache_attribute_for_ip ${real_ip} "pc_login" )
	    ;;

	*)
	    echo "ERROR: bas action ${action}" 1>&2
	    echo ">>>>> ${line}" 1>&2
	    ;;
    esac
      
    gelf_headers='"version": "1.1",
  "host": "'${HOSTNAME}'",
  "short_message": "generated by test from command line at '${PGM_BASENAME}' at '$(date)'",
  "full_message": "... none ...",
  "level": 3,
'
    # generated timestamp
    gelf_headers=${gelf_headers}'  "timestamp": '${epoch_time}

    # generate each specific field
    gelf_body=$(
	echo -n ', "_pc_service": "'${SERVICE_NAME}'"'

	echo -n ', "_action": "'${action}'"'
    
	if [[ -n "${status}" ]]
	then
	    echo -n ', "_status": "'${status}'"'
	fi

	if [[ -n "${pc_login}" ]]
	then
	    echo -n ', "_pc_login": "'${pc_login}'"'
	fi

	if [[ -n "${real_ip}" ]]
	then
	    echo -n ', "_real_ip": "'${real_ip}'"'
	fi

	if [[ -n "${user_agent}" ]]
	then
	    echo -n ', "_user_agent": "'${user_agent}'"'
	fi

	if [[ -n "${vin}" ]]
	then
	    echo -n ', "_vin": "'${vin}'"'
	fi
	
	if [[ -n "${doc_ref}" ]]
	then
	    echo -n ', "_doc_ref": "'${doc_ref}'"'
	fi
	     )

    gelf_line='{ '${gelf_headers},${gelf_body}' }'

    # FIXME: not yet implemented
    echo '>>>'${gelf_line}'<<<<'

    echo -n "${gelf_line}" | nc -w0 -u "${GELF_UDP_HOST}" "${GELF_UDP_PORT}"
    # TODO: handle connection errors
}

#
# reorder all records in timestamp order
#
sort \
    -n \
    -k 1 \
    -o /tmp/time_ordered_stats.txt \
${all_stat_files}


cat /tmp/time_ordered_stats.txt | \
    while read -r line
    do
	generateAndSendGELFLog "${line}"
    done

touch "${RUN_STATES_DIR}/last_call.status"
